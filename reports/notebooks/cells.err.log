Traceback (most recent call last):
  File "/scratch3/BMC/wrfruc/gge/Miniforge3/envs/pyDAmonitor/lib/python3.11/site-packages/jupyter_core/utils/__init__.py", line 154, in wrapped
    asyncio.get_running_loop()
RuntimeError: no running event loop

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "/scratch3/BMC/wrfruc/gge/Miniforge3/envs/pyDAmonitor/lib/python3.11/site-packages/jupyter_cache/executors/utils.py", line 58, in single_nb_execution
    executenb(
  File "/scratch3/BMC/wrfruc/gge/Miniforge3/envs/pyDAmonitor/lib/python3.11/site-packages/nbclient/client.py", line 1319, in execute
    return NotebookClient(nb=nb, resources=resources, km=km, **kwargs).execute()
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/scratch3/BMC/wrfruc/gge/Miniforge3/envs/pyDAmonitor/lib/python3.11/site-packages/jupyter_core/utils/__init__.py", line 158, in wrapped
    return loop.run_until_complete(inner)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/scratch3/BMC/wrfruc/gge/Miniforge3/envs/pyDAmonitor/lib/python3.11/asyncio/base_events.py", line 654, in run_until_complete
    return future.result()
           ^^^^^^^^^^^^^^^
  File "/scratch3/BMC/wrfruc/gge/Miniforge3/envs/pyDAmonitor/lib/python3.11/site-packages/nbclient/client.py", line 709, in async_execute
    await self.async_execute_cell(
  File "/scratch3/BMC/wrfruc/gge/Miniforge3/envs/pyDAmonitor/lib/python3.11/site-packages/nbclient/client.py", line 1062, in async_execute_cell
    await self._check_raise_for_error(cell, cell_index, exec_reply)
  File "/scratch3/BMC/wrfruc/gge/Miniforge3/envs/pyDAmonitor/lib/python3.11/site-packages/nbclient/client.py", line 918, in _check_raise_for_error
    raise CellExecutionError.from_cell_and_msg(cell, exec_reply_content)
nbclient.exceptions.CellExecutionError: An error occurred while executing the following cell:
------------------
import numpy as np
import matplotlib.pyplot as plt
import cartopy.crs as ccrs
from netCDF4 import Dataset
cartopy.config['data_dir'] = f"{pyDAmonitor_ROOT}/data/natural_earth_data"

mylat, mylon0 = 40.14, -105.18   # specify a given lot, lon

lat_incr = 0.01  # degreee, ~1km?
lon_incr = 0.01  # degree, ~1km?

mylon = mylon0 + 360  # convert to 360-based degree
lonCell = np.degrees(ds.variables['lonCell'][:])
latCell = np.degrees(ds.variables['latCell'][:])
lonVertex = np.degrees(ds.variables['lonVertex'][:])
latVertex = np.degrees(ds.variables['latVertex'][:])

# Connectivity: vertices of each cell
verticesOnCell = ds.variables['verticesOnCell'][:]  # shape (nCells, maxEdges)
nEdgesOnCell = ds.variables['nEdgesOnCell'][:]

# find neighborhood cells (>=7)
for iter in range(10):
    latmin = mylat - lat_incr * (iter + 1)
    latmax = mylat + lat_incr * (iter + 1)
    lonmin = mylon - lon_incr * (iter + 1)
    lonmax = mylon + lon_incr * (iter + 1)
    
    maskC = (latCell >= latmin) & (latCell <= latmax) & (lonCell >= lonmin) & (lonCell <= lonmax)
    latC = latCell[maskC]
    lonC = lonCell[maskC]
    vertC = verticesOnCell[maskC]
    nEdgesC = nEdgesOnCell[maskC]
    print(latC.size)
    if latC.size >= 7: 
        break  # exit the loop if we find 7+ cells

# find the cell indices 
iCell = ds0.variables['indexToCellID'][:][maskC]
# ter = ds0.variables["ter"][:][mask]

# --- Plot ---
fig = plt.figure(figsize=(10, 10))
ax = plt.axes(projection=ccrs.PlateCarree())

# add costlines, country borders, state/province borders
ax.coastlines(resolution='50m')  # '110m', '50m', or '10m'
ax.add_feature(cfeature.BORDERS, linewidth=0.7)
ax.add_feature(cfeature.STATES, linewidth=0.5, edgecolor='gray')
ax.add_feature(cfeature.LAND, facecolor=cfeature.COLORS['land'])
ax.add_feature(cfeature.OCEAN, facecolor=cfeature.COLORS['water'])

# relax the plotting extent by the "buffer" degree
buffer = 0.02
ax.set_extent([lonmin - buffer, lonmax + buffer, latmin - buffer, latmax + buffer])

# plot ploygons
for i in range(latC.size):
    nEdges = nEdgesC[i]
    verts = verC[i, :nEdges] - 1  # convert 1-based to 0-based index
    poly_lon = lonVertex[verts]
    poly_lat = latVertex[verts]
    ax.fill(poly_lon, poly_lat, edgecolor="black", facecolor="none", linewidth=0.5, transform=ccrs.PlateCarree())
    # add the cell index in the center of the cell
    ax.text(lonC[i], latC[i], f'{iCell[i]}', 
        transform=ccrs.PlateCarree(),
        fontsize=8, color="blue",
        ha="center", va="center")
    
# Plot a star at the user specificed (mylon, mylat)
ax.plot(mylon, mylat, marker="*", color="red", markersize=5,  # o, ^, s
        transform=ccrs.PlateCarree())

plt.show()
------------------


[31m---------------------------------------------------------------------------[39m
[31mNameError[39m                                 Traceback (most recent call last)
[36mCell[39m[36m [39m[32mIn[11][39m[32m, line 13[39m
[32m     10[39m lon_incr = [32m0.01[39m  [38;5;66;03m# degree, ~1km?[39;00m
[32m     12[39m mylon = mylon0 + [32m360[39m  [38;5;66;03m# convert to 360-based degree[39;00m
[32m---> [39m[32m13[39m lonCell = np.degrees([43mds[49m.variables[[33m'[39m[33mlonCell[39m[33m'[39m][:])
[32m     14[39m latCell = np.degrees(ds.variables[[33m'[39m[33mlatCell[39m[33m'[39m][:])
[32m     15[39m lonVertex = np.degrees(ds.variables[[33m'[39m[33mlonVertex[39m[33m'[39m][:])

[31mNameError[39m: name 'ds' is not defined

